package jda.modules.dcsl.syntax;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

import jda.modules.common.CommonConstants;
import jda.modules.dcsl.syntax.query.QueryDef;

/**
 * @overview Defines a domain constraint of some attribute
 * @author dmle
 * @version 2.0
 */
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DAttr {
    
  //public static final String NullString = /*v2.6.4b: "\u0000"; */ "\u2400"; 
  
  /**the name of this attribute, which must be the same as the name of the Java class field
   * to which this domain constraint is applied. 
   * <p>For example, if this domain constraint is applied to the <code>Student.id</code> field
   * then <code>name</code> must be set to <code>id</code>. 
   */
  public String name();  
  
  /**whether or not this attribute is an identifier, e.g. Student.id.<br>
   * Default: <code>false</code>
   * */
  public boolean id() default false;
  
  /** 
   * Use this ONLY if {@link #id()} = <tt>false</tt>.<br>
   * 
   * Whether or not this attribute is a candidiate identifier.
   * 
   * <br>Default: <tt>false</tt> 
   * @see also {@link #ccid()} 
   * 
   */
  public boolean cid() default false;
  
  /**
   * Use this ONLY if {@link #id()} = <tt>false</tt>.<br>
   * <b>NOT YET SUPPORTED</b>
   * 
   * If this attribute is part of a <b>composite</b> candidate identifier then 
   * this sets the virtual name of this identifier. All attributes sharing this 
   * identifier name will form the composite identifier.
   * 
   * <br>Default: {@link CommonConstants#NullString}
   * 
   * @see also {@link #cid()}
   */
  public String ccid() default CommonConstants.NullString;
  
  /**The type of this attribute, which must be the simple name of the declared type of the 
   * corresponding class field or <code>Type.UserDefined</code> if the declared type
   * is not one of the basic built-in Java types.<br>
   * Default: {@link #Type.Null}
   */ 
  public Type type() default Type.Null;

  /**<code>true</code> if the values of the associated attribute are automatically 
   * generated by the system (i.e. not specified by the user)
   * <p>Note: if <code>auto</code> is true then mutable must be set to false (i.e. 
   * the attribute is immutable).<br>
   * Default: <code>false</code>
   * 
   * @TODO support domain-typed attribute<br>
   * - {@link #auto()} currently cannot be set on a domain-typed attribute (i.e. {@link #type()} = {@link Type#Domain})
   * (b/c the retrieval of auto-attribute value range does not currently support this type of attribute) 
   * */
  public boolean auto() default false;

  // v2.7.3 congnv: add autoIncrement()
  /**<code>true</code> if the values of the associated attribute are automatically 
   * incremented by the DBMS (i.e. table id of the integer type)
   * <p>Note: if <code>autoIncrement</code> is true then mutable must be set to false (i.e. 
   * the attribute is immutable) AND only applicable to numeric types (i.e. {@see #type().isNumeric()} returns true).<br>
   * Default: <code>false</code>
   * */
  public boolean autoIncrement() default false;
  
  //v2.7.3 congnv: add unique()
  /**<code>true</code> if the value of the associated attribute must be unique, otherwise false.<br>
   * <p>Note: if <code>unique</code> is true then optional must be set to false
   * Default: <code>false</code>*/
  public boolean unique() default false;
 
  /**
   * <code>true</code> if the associated attribute is editable, otherwise false.
   * <p>Note: if <code>auto</code> is true then mutable must be set to false (i.e. 
   * the attribute is immutable). 
   * 
   * <br>Immutability is, however, not the same as auto in that an immutable attribute 
   * may have it value initialised once via a user-accessible constructor (and is unchanged thereafter), 
   * while the values of an auto attribute cannot be initialised via any user-accessible 
   * (public) constructors. <br>
   * Default: <code>true</code>
   */
  public boolean mutable() default true;

  /**<code>true</code> if the value of the associated attribute may be un-defined (e.g. null), otherwise false.<br>
   * Default: <code>true</code>*/
  public boolean optional() default true;
  
  /**the maximum length of the attribute value (only applicable to non-numeric, non-userdefined type)<br>
   * Default: <code>MetaConstants#DEFAULT_DATTR_LENGTH</code>
   **/
  public int length() default  DCSLConstants.DEFAULT_DATTR_LENGTH;

  /**the lower range value (only applicable to numeric types (i.e. {@see #type().isNumeric()} returns true))<br>
   * Default: <code>Double.NEGATIVE_INFINITY</code>
   * */
  public double min() default CommonConstants.DEFAULT_MIN_VALUE;
  
  /**the upper range value (only applicable to numeric types (i.e. {@see #type().isNumeric()} returns true).<br>
   * Default: <code>Double.POSITIVE_INFINITY</code>*/
  public double max() default CommonConstants.DEFAULT_MAX_VALUE;
  
  /**
   * if specified then contains the names of the domain attributes from which 
   * this attribute is derived. For example, if this attribute is <tt>Person.age</tt>
   * then its domain constraint would have <tt>derivedFrom={"dateOfBirth"}. 
   * 
   * <p><b>Important</b>: if there are more than one domain attributes to be specified in  
   * <tt>derivedFrom</tt> then these must be listed in the order that they are defined in the class.
   *  
   * 
   * <br>Default: <tt>{}</tt> (an empty array)
   */
  public String[] derivedFrom() default {};
  

  /**
   * (Optional) specifies the name of the domain attribute of this class whose values are used 
   * to create a data source for this attribute.
   * 
   * <p>Default: {@link CommonConstants#NullString}
   * 
   * @version 3.0
   */
  public String sourceAttribute() default CommonConstants.NullString;

  /**
   * (Optional) specifies whether this attribute is specified with an {@link QueryDef} 
   * that defines the domain objects for use as value of this attribute.
   * 
   *  <p>This applies only to {@link #auto()} and {@link Type#Collection}-typed attributes whose values
   *  can automatically be retrieved from the data source.
   *  
   * <p>Default: <tt>false</tt> (i.e. no source query is used)
   * @version 3.1 
   */
  public boolean sourceQuery() default false;


  /**
   *  (Optional) specifies whether this attribute is specified with a <b>complex</b> query -- i.e. 
   *  one that CANNOT be defined by {@link QueryDef}.  
   *  
   *  <p>This is used as <b>an alternative</b> for {@link #sourceQuery()} (which is used for simple queries). 
   *  DONOT use both please!
   *  
   *  <p>This applies only to {@link #auto()} and {@link Type#Collection}-typed attributes whose values
   *  can automatically be retrieved from the data source.
   * 
   * <p>Default: <tt>false</tt> (i.e. no source query is used)
   */
  public boolean sourceQueryHandler() default false;
  
//  /**
//   * Another way to specify <tt>min</tt>: <br>
//   * to specify which domain class 
//   * and its attribute whose value is to be used a the min value for this attribute.
//   * Default: <tt>@Select(clazz=Null)</tt>
//   */
//  public Select minFilter() default @Select();
  
  /**
   * the <b>fixed</b> default value of this attribute (applied only to primitive types). 
   * 
   * <br>Use {@link #defaultValueFunction()} if a more flexible default value generation scheme is needed.   
   * 
   * Default: <code>{@link CommonConstants#NullString}</code>*/
  public String defaultValue() default CommonConstants.NullString; 
  
  /**
   * Whether not not the default value of this attribute is generated by a function (which <b>must</b> implemented by its 
   * domain class).
   * 
   * <br>Unlike {@link #defaultValue()}, which only allows for the specification of a fixed default value, 
   * this property allows applications to flexibly specify how the default value is generated.  
   * 
   * <br>Default: <tt>false</tt>
   * @version 2.7.4
   * 
   * <p><b>example</b><br>
    <pre>
     // attribute
     
     @DomainConstraint(name="academicYear",type=Type.Integer,length=10,min=0,optional=false,defaultValueFunction=true)
     private int academicYear; 
     // default value function 
     @Metadata(type=Metadata.Type.MethodDefaultValueFunction)
     @MemberRef(name="academicYear")
     public static int createDefaultAcademicYear() {
        // use the current calendar year
        Calendar cal = Calendar.getInstance();
        return cal.get(Calendar.YEAR);
     }
    </pre>
   */
  public boolean defaultValueFunction() default false;
  
  /** whether or not the values of this attribute are to be serialised when the 
   *  objects of the class are serialised.<br> 
   *  Default: <code>true</code>*/
  public boolean serialisable() default true;
  
  /**
   * This field is primarily used to specify the <b>output</b>attributes of a Report class. 
   * 
   * <p>It is applicable only to <b>collection-type attribute</b>: <br>
   * to specify which domain class 
   * and its attributes are to be "selected" for the objects stored in a collection. It  
   * has the same purpose as the SQL SELECT statement. 
   * Default: <tt>@Select()</tt>
   */
  public Select filter() default @Select();
  
//  /**
//   * Only applicable to attributes that implement associations.<br>
//   * Default: {@link #Null}
//   * @deprecated do not use this property; it is to be removed
//   */
//  public String role() default Null;
  

  /**
   * The format string that applies to the value of this field. It is useful 
   * for fields that take values that conform to a certain format (e.g. date). 
   * Default: {@link Format#Nil} (no format) 
   */
  public Format format() default Format.Nil;
  

  /**
   * 
   * @effects 
   *  Whether or not this domain attribute is a virtual attribute. A virtual attribute is a domain attribute
   *  that is used as the source to provide data for other domain attributes (configured via {@link #sourceAttribute()). 
   *  The attribute value is NOT to be set by the user but set internally by the application (e.g. via a query to retrieve objects from the data source)
   *  
   *  <p>Thus, a virtual attribute is <b><i>not viewable</i></b> on an object form. 
   *  
   * @version 3.3
   */
  public boolean virtual() default false;
  
  /***
   * Used in {@link DAttr#format()}
   * 
   * @author dmle
   */
  public static enum Format {
    /** date format: dd/MM/yyyy (e.g. 01/06/2015)*/
    Date("dd/MM/yyyy")
    /** time (of day) in 24-hour format with hour (0-23) and minute (0-59): H:m (e.g. 08:10, 14:20, etc.)*/
    ,TimeHM("H:m")
    /**month of the year: MM/yyyy (e.g. 06/2015)*/
    , MonthOfYear("MM/yyyy")
    /** currency format */
    ,Currency(null),
    /**real numbers with >= 1 integer digit and no fraction digits, e.g. 10 */
    WholeNumber("#"),  // v3.0
    /**real numbers with >= 1 integer digit and 1 fraction digits, e.g. 10.5 */
    Number1Dot1("#.#"),  // v3.0
    /** fixed phone in Vietnam: 10 digits*/
    FixedPhone("(##) ########"),
    /** cell phone in Vietnam: 11 digits*/
    CellPhone("#### ###-####"),
    /** no format */
    Nil(null)
    ;
    
    private String formatString;
    private Format(String formatString) {
      this.formatString=formatString;
    }
    
    public String getFormatString() {
      return formatString;
    }
    
    public boolean isNull() {
      return formatString == null;
    }
    
    public boolean isCurrency() {
      return this == Currency;
    }
  } // end Format
  
  public static enum Type {
    String,
    StringMasked,
    Char,
    //PInteger,
    Integer,
    BigInteger,   // v2.7.2
    //PLong,
    Long,
    //PFloat,
    Float,
    //PDouble,
    Double,
    Boolean, 
    //Object,
    /** domain specific type*/
    Domain, 
    Collection, // collection type (e.g. List)
    // v2.7.3: 
    Array,
    /** java.awt.Color */
    Color,
    /** java.awt.Font */
    Font,
    /** java.io.File */
    File,
    Null,
    /** javax.swing.ImageIcon*/
    Image,
    /** java.util.Date */
    Date,
    Short, Byte, ByteArraySmall, ByteArrayLarge,  // v2.6.4.b
    /** implements java.io.Serializable */
    Serializable,
    /** some type that we donot care to know */
    Other, 
    ;
    
    public boolean isNumeric() {
      return (this == Type.Integer ||
          this == Type.BigInteger ||  // v2.7.2
          this == Type.Short || 
          this == Type.Long ||
          this == Type.Float ||
          this == Type.Double 
      );
    }    

    public boolean isShort() {
      return this==Type.Short;
    }

    public boolean isByte() {
      return this==Type.Byte;
    }

    public boolean isInteger() {
      return this==Type.Integer;
    }
    
    public boolean isLong() {
      return this==Type.Long;
    }
    
    public boolean isBigInteger() {
      return this == Type.BigInteger;
    }
    
    public boolean isDecimal() {
      return isBigInteger();
    }

    public boolean isFloat() {
      return this==Type.Float;
    }
    public boolean isDouble() {
      return this==Type.Double;
    }
    
    public boolean isString() {
      return this.equals(Type.String) || 
      isStringMasked() || 
      this.equals(Type.Char) || 
      this.equals(Type.Other);
    }
    
    public boolean isStringMasked() {
      return this == Type.StringMasked;
    }
    
    public boolean isBoolean() {
      return this == Type.Boolean;
    }
    public boolean isNull() {
      return this == Type.Null;
    }
    public boolean isDomainType() {
      return this == Type.Domain;
    }
    public boolean isCollection() {
      return this == Type.Collection;
    }
    /**
     * 
     * @effects 
     *  if this is {@link #Domain} or a type that refers to a domain class, e.g. {@link #Collection}
     *    return <tt>true</tt>
     *  else
     *    return <tt>false</tt> 
     * @version 3.2
     */
    public boolean isDomainReferenceType() {
      return isDomainType() || isCollection();
    }
    public boolean isArray() {
      return this == Array;
    }
    public boolean isPrimitive() {
      return isString() || isNumeric() || isBoolean();
    }

    /**
     * @effects 
     *  return {@link #isPrimitive()} /\ !{@link #isBoolean()}
     * @version 3.2
     */
    public boolean isPrimitiveExceptBoolean() {
      return isString() || isNumeric();
    }

    public boolean isColor() {
      return this == Type.Color;
    }
    
    public boolean isFont() {
      return this == Type.Font;
    }
    
    public boolean isFile() {
      return this == Type.File;
    }
    
    public boolean isByteArray() {
      return this == Type.Image || this == Type.File ||  
          this == Type.ByteArrayLarge || this == Type.ByteArraySmall;
    }
    
    public boolean isChar() {
      return this == Type.Char;
    }
    
    public boolean isDate() {
      return this == Type.Date;
    }
    
    public boolean isImage() {
      return this == Type.Image;
    }
    
    public boolean isSerializable() {
      return this == Type.Serializable;
    }

    /**
     * @effects
     *  if this type is comparable
     *    return true
     *  else
     *    return false
     */
    public boolean isComparable() {
      return !isByteArray();
    }

    /**
     * A multi-valued data type {@link #isListType()} AND that enables a user to specify more than one 
     * input values.  
     * 
     * @effects 
     *  if this represents a multi-valued type (e.g. {@link #Collection}) 
     *    return true
     *  else
     *    return false
     *  @version 
     *  - 3.2: changed to return other cases, including {@link #Collection} and {@link #Array}
     */
    public boolean isMultiValued() {
      // add other cases below (if needed)
      /* v3.2:
       * return isBoolean();
       */
      return isCollection() || isArray();
    }

    /**
     * This includes data types that satisfy {@link #isMultiValued()} and also others (e.g. Boolean)  
     * 
     * @effects 
     *  if this represents a list-typed data type (e.g. Boolean) 
     *    return true
     *  else
     *    return false
     *  @version 3.2
     */
    public boolean isListType() {
      return isBoolean() || isCollection() || isArray();
    }

    @DAttr(name="name",id=true,type=Type.String,length=30,mutable=false,optional=false)
    public String getName() {
      return name();
    }
  } // end Type
}