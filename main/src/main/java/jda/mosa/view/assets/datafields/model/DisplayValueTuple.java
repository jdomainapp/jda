package jda.mosa.view.assets.datafields.model;

import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map.Entry;

import jda.modules.dcsl.syntax.DAttr;
import jda.modules.dcsl.syntax.DAttr.Type;

/**
 * @overview 
 *  Represents a user-friendly value tuple, whose elements are well-defined
 *  by <tt>DomainConstraint</tt>s
 *   
 * @author dmle
 */
public class DisplayValueTuple<T> {
  // must not contain space
  private final static String SEP = "|";

  // change this (if required) when SEP is changed
  private final static String PARSE_PATTERN = "\\"+SEP;
  
  private LinkedHashMap<DAttr,T> contentMap;
  
  public DisplayValueTuple() {
    //
    contentMap = new LinkedHashMap<DAttr,T>();
  }

  /**
   * @effects
   *  add (dc,val) to <tt>this</tt>
   */
  public void addElement(DAttr dc, T val) {
    contentMap.put(dc,val);
  }
  
//  /**
//   * @effects 
//   *  return the last element of this
//   */
//  public T getLastElement() {
//    if (contentMap.isEmpty())
//      return null;
//    
//    Collection<T> valSet = contentMap.values();
//    Iterator<T> valSetIt = valSet.iterator();
//    T last = null;
//    while (valSetIt.hasNext()) {
//      last = valSetIt.next();
//    }
//    
//    return last;
//  }
  

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result
        + ((contentMap == null) ? 0 : contentMap.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    DisplayValueTuple other = (DisplayValueTuple) obj;
    if (contentMap == null) {
      if (other.contentMap != null)
        return false;
    } else if (!contentMap.equals(other.contentMap))
      return false;
    return true;
  }

  /**
   * @effects 
   *  if this is empty
   *    return an empty string (i.e. <tt>""</tt>)
   *  else 
   *    return a display-friendly string of this
   */
  @Override
  public String toString() {
    StringBuffer sb =  new StringBuffer();
    
    int sz = contentMap.size();
    T e;
    DAttr dc;
    int length;
    String formatSpec;
    int i = 0;
    for (Entry<DAttr,T> entry : contentMap.entrySet()) {
      dc = entry.getKey();
      e = entry.getValue();
      length = dc.length();
      if (length == -1) 
         formatSpec = null;
      else
        formatSpec = "%-"+length+"s"; // left justified
      
      if (formatSpec != null)
        sb.append(String.format(formatSpec, e));
      else  // no format
        sb.append(e);
      
      if (i < sz-1)
        sb.append(SEP).append(" ");
      
      i++;
    }
    
    return sb.toString();
  }

  /**
   * @requires 
   *  <tt>s</tt> has the same format as that generated by {@link DisplayValueTuple#toString()}
   *  
   * @effects
   *  if s is <tt>null</tt>
   *    return <tt>null</tt>
   *  else
   *    return a <tt>DisplayValueTuple</tt> whose elements are those contained in <tt>s</tt> and 
   *    whose corresponding <tt>DomainConstraint</tt>s are specified by <tt>attribs</tt>
   *    
   *  <p>Throws IllegalArgumentException if the input is invalid.
   */
  public static Object parseString(String s, DAttr[] attribs) throws IllegalArgumentException {
    String[] items = s.split(PARSE_PATTERN);
    
    if (items.length !=  attribs.length)
      throw new IllegalArgumentException(DisplayValueTuple.class.getSimpleName() + 
          ".parseString: number of domain constraints does NOT match the number of items in : " + s);
    
    String item;
    Object itemVal;
    DAttr attrib;
    DisplayValueTuple t = new DisplayValueTuple();
    for (int i = 0; i < items.length; i++) {
      item = items[i];
      item = item.trim();
      attrib = attribs[i];
      
      // convert item into the correct data value as specified by attrib
      itemVal = parseValue(item, attrib);
      
      t.addElement(attrib, itemVal);
    }
    
    return t;
  }
  
  /**
   * @effects returns the object of the correct type for <code>value</code>, which is specified
   *          in the domain constraint <code>constraint</code>; throws
   *          <code>IllegalArgumentException</code> if <code>value</code>'s type
   *          is not compatible with the type specified in the domain
   *          constraint.
   */
  private static Object parseValue(Object value, DAttr d)
      throws IllegalArgumentException {
    Object val = value;

    if (d != null && value != null) {
      Type type = d.type();

      try {
        if (type.isString()) {
          val = value.toString();
        } else if (type.isNumeric()) {
          // create a number
          if (!(value instanceof Number)) {
            try {
              if (type.equals(Type.Integer)) {
                val = Integer.parseInt(value.toString());
              } else if (type.equals(Type.Long)) {
                val = Long.parseLong(value.toString());
              } else if (type.equals(Type.Float)) {
                val = Float.parseFloat(value.toString());
              } else if (type.equals(Type.Double)) {
                val = Double.parseDouble(value.toString());
              }
            } catch (NumberFormatException e) {
              // System.err
              // .println("DomainSchema.validateDomainValue: invalid value "
              // + value);
              throw new IllegalArgumentException("invalid value " + value);
            }
          }
        } // end is-numeric
        else if (type.isBoolean() && !(value instanceof Boolean)) {
          val = Boolean.parseBoolean(value.toString());
        }
      } catch (Exception e) {
        throw new IllegalArgumentException("invalid value " + value);
      }
    }

    // if we get here then ok
    return val;
  }

  /**
   * @effects 
   *  return the number of elements in this
   */
  public int size() {
    return contentMap.size();
  }
  
  /**
   * @effects 
   *  return the <tt>i</tt>th <tt>DomainConstraint</tt> in this
   *  (<tt>0 <= i < this.size()</tt>); or <tt>null</tt> if an invalid <tt>i</tt> was specified 
   */
  public DAttr getDomainConstraint(int i) {
    if (i < 0 || i > size()) {
      return null;
    }
    
    Iterator<DAttr> keyIt = contentMap.keySet().iterator();
    
    for (int j = 0; j < i;j++) {
      keyIt.next();
    }
    
    return keyIt.next();
  }
  
  /**
   * @effects 
   *  return the <tt>i</tt>th element of this
   *  (<tt>0 <= i < this.size()</tt>); or <tt>null</tt> if an invalid <tt>i</tt> was specified 
   */
  public T getElement(int i) {
    if (i < 0 || i > size()) {
      return null;
    }
    
    Iterator<Entry<DAttr,T>> entriesIt = contentMap.entrySet().iterator();
    
    for (int j = 0; j < i;j++) {
      entriesIt.next();
    }
    
    return entriesIt.next().getValue();
  }
}
